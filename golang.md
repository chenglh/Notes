**Go基础巩固加强**

###### 第一章 指针

指针是一个代表着某个内存地址的值。Go语言保留了指针，但与c语言指针有所不同，主要表现：

1、默认值是nil

2、& 取变量地址；* 通过指针访问目标对象

3、不支持指针运算，直接用  " . " 访问目标成员

~~~go
var a int = 10
var p *int = &a

*p = 100 // 这里是 取值运算符 *，也叫解引用或间接引用。 修改内存值为250 
~~~



**栈帧的内存布局**

32位操作系统，2的32次方 = 4G内存

62位操作系统，2的64次方 = 16G内存

Kernel内核，操作系统的主体部分，驱动等；0-3G是用户区；data区是全局初始化的存放的区，

<img src="Golang.assets/image-20200831172615864.png" style="float:left;" />



栈帧：用来给函数运行提供内存空间。取内存于stack上。

当函数调用时，产生栈帧。函数调用结束，释放栈帧。

栈帧存储：1、局部变量，2、形参。（形参与局部变量存储地位等同）3、内存字段描述值（记录栈基、栈顶指针位置）



stack开辟一片空间来运行 main()，main()里边有函数Test()，再在 main在相邻内存空间再开辟一块来运行

Test()函数。函数运行完要释放内存空间。

~~~go
func test(m int) {
	var b = 10
}
func main() {
	var a = 10
	var p *int = &a
    test(10)
}
~~~

<img src="golang.assets/image-20200918210154059.png" alt="image-20200918210154059" style="zoom:50%;float:left;" />



指针使用注意：

空指针：未被初始化的指针。var  p  *int

野指针：被一片无效空间初始化。var p *int = 0xc00001c080  程序直接飘红，不能编译通过。



以上使用指针变量，都需要另一个变量来跟随取地址。可以使用new来初始化指针变量，而new出来的内存地址是在 heap（堆）上面的。

~~~go
func main() {
	//在 heap 上申请一片内存地址空间
	var p *int
	p = new(int) //8字符空间大小，p是地址，对应的值是，默认类型的零值
	fmt.Println(*p)
}
~~~



~~~go
var a int = 10
var b int = 20 //b是一个变量名称，指向的是一个内存地址； b也是左值

a = b //b是右值，即变量b所指向的值
~~~



变量存储：等号左边的变量，代表变量所指向的内存空间。

等号右边的变量，代表变量内存空间存储的数据值。

~~~go
func test () {
	var p *int
	*p = 100
}
//函数是在栈帧上的，运行完回收内存空间
//如果参数是传指针变量，因为指针是存放在堆空间上的，没有在栈空间上，所以不会被消毁
~~~



栈 stack的空间在32位操作系统上是 1M-8M，但是heap堆却 1G+

如果指针不再使用，可以置成 nil，gc是去回收。



**函数new**

表达式 new(T) 将创建一个T类型的匿名变量，所做的是为T类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的T类型值的指针值，返回的指针类型为 *T。

new创建的内存空间位于heap上，空间的默认值为数据类型的默认值。如， var p = new(int) 则 *p 为 0。



我们只需使用 new()函数，无需担心其内存的生命周期或怎样将其删除，因为Go语言的内存管理会帮我们打理一切。



传地址(引用)：将地址值作为函数参数、返回值后传递。

传值(数据值)：将实参的值，拷贝一份给形参。

~~~go
func swap(a, b int)  {
	a,b = b, a
	fmt.Println("swap : a = ",a," b= ", b)
}

func main()  {
	a,b := 10, 20
	swap(a, b)
	fmt.Println("main : a = ",a," b= ", b)
}
/**
swap : a =  20  b=  10
main : a =  10  b=  20
*/
~~~































